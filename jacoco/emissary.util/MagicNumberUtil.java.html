<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MagicNumberUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Emissary</a> &gt; <a href="index.source.html" class="el_package">emissary.util</a> &gt; <span class="el_source">MagicNumberUtil.java</span></div><h1>MagicNumberUtil.java</h1><pre class="source lang-java linenums">package emissary.util;

import emissary.util.magic.MagicNumber;
import emissary.util.magic.MagicNumberFactory;
import emissary.util.shell.Executrix;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

/**
 * Magic entry rules when using the Java utility, MagicNumberUtil
 *
 * A. Examples:
 *
 * Java ByteCode From Larry Schwimmer (schwim@cs.stanford.edu) 0 belong 0xcafebabe compiled Java class data, &amp;gt;6
 * beshort x version %d. &amp;gt;4 beshort x \b%d
 *
 * The entries must have 4 columns where the first three are delimited by blank space as tabs, or spaces, or both and
 * the remaining columns will be stored as the description. Since spaces are also delimiters - if the value column
 * (third column) requires a space then it should be escaped.
 *
 * B. Offset Column 1. A decimal, hex, or octal value preceded or not preceded by '&amp;gt;' 2. Decimal: n* - if the
 * occurrences is &amp;gt; 1, then not preceded by '0' 3. Hex: 0xn* 4. Octal: 0n* 5. Offset values in the format '(n.s+32)'
 * are ignored. These only occurred in the continuations
 *
 * C. Data Type Column 1. BYTE, SHORT, LONG, STRING, BESHORT, BELONG, LESHORT, LELONG 2. LEDATE, BEDATE, and DATE are
 * not supported 3. Masking: If the data type is followed by a mask value in decimal, octal or hex and delimited by
 * '&amp;amp;' then the value column will be stored as the product of the masking. The mask value cannot exceed the data
 * type length.
 *
 * D. Value columns 1. String, Byte, Short, or Long - 1, 2, or 4 byte values - or any length value for the string type.
 * 2. String values can be escaped. a. Example &quot;\0\40\320\3200\4text\ \7\x40\r\t\&quot; parsed as: &quot;0-32-208-208-0-4-text-
 * -7-64- &quot; with the dashes removed.
 *
 * 1. Escaping number values Numbers can be of length up to three octal or two hex and can also be terminated by
 * non-digits and finally must be less then 256. These numeric values are substituted into their respective byte
 * positions.
 *
 * - 3200 will be evaluated as '320' octal and '0' string. - 0 as 0 octal - 40 as 40 octal - x40 as 40 hex which is 64 -
 * 4text as 4 and succeeded by the characters 't' 'e' 'x' 't'
 *
 * 2. Escaping characters including spaces - Spaces must be escaped - otherwise they'll be tokenized into the next
 * column - 4\ 4\4 results in [char 4, char space, char 4, integer 4] - Ascii values 8-15 can be escaped as: \b\t\n\r
 * etc... see man page for ascii - trailing slashes will result in the placement of a trailing space
 *
 * 3. Substitution Example &amp;gt;4 beshort x \bversion %d.%c Substitution is allowed for continuations only. In this case,
 * the short byte array will be sampled from the document at offset 4 and length 2. This stored value can be substituted
 * in the description field where %c or %s will substitute convert the number into a unicode character and %d %ld and
 * other numeric data types will instead substitute the numeric value.
 *
 * In the above, if value 'x' at offset 4 equals 0101 octal, then the substitutions will be a decimal value of 64 and
 * the character value of 'A' resulting in: &quot;\bversion 64.A
 *
 * E. Description The description is comprised of all remaining columns once the first three have been discovered. They
 * can be blank in continuations since continuations may depend upon the successful testing of preceding continuations.
 * In other words:
 *
 * 0 long 0xcafebabe java binary &amp;gt;4 byte x version %d
 *
 * can be re-written as
 *
 * 0 short 0xcafe java &amp;gt;4 byte 0xba &amp;gt;&amp;gt;6 byte 0xbe \b\bbinary &amp;gt;&amp;gt;&amp;gt;4 byte x version %d
 *
 * where the continuations will only occur upon the completion of '&amp;gt;4 byte 0xba'
 *
 * 1. The descriptions can be escaped with a '\b' 2. Each continuation is prefixed with a space when added to a
 * description. To avoid this or remove spaces use the '\b' backspace and it will perform a backspace function or trim
 * previous character. 3. See Value column for substitution rules
 */

public final class MagicNumberUtil {

<span class="fc" id="L80">    private static final Logger log = LoggerFactory.getLogger(MagicNumberUtil.class);</span>

    /** The magic number instances */
<span class="fc" id="L83">    private final List&lt;MagicNumber&gt; magicNumbers = new ArrayList&lt;&gt;();</span>

    /**
     * Log flag for storing parse errors - they will just be discarded. Switching this on will allow erroneous entries to be
     * logged and can be retrieved using the method getErrorLog to find out which entries had parsing errors. Using the
     * magic file shipped with version unix file 3.39 only three/four primary entries were unsupported - these had to do
     * with signed data types such as ubelong. Or the value was larger then the specified data type which occurred once.
     * Otherwise, remaining errors were in continuations - mainly when the offset value was in the form of n.s+32 where 'n'
     * is a decimal value and 's' could not be determined.
     */
<span class="fc" id="L93">    private boolean logErrors = false;</span>

    /**
     * Log data structure for continuations. Maps entries with depth 0 with a List of continuation entries containing the
     * errors
     */
<span class="fc" id="L99">    private final Map&lt;String, List&lt;String&gt;&gt; extErrorMap = new TreeMap&lt;&gt;();</span>

    /**
     * Log data structure for entries with a depth of '0' - these are the important entries. Just maintains a simple list of
     * these entries
     */
<span class="fc" id="L105">    private final List&lt;String&gt; errorList = new ArrayList&lt;&gt;();</span>

    /**
     * Private Constructor
     */
<span class="fc" id="L110">    public MagicNumberUtil() {}</span>

    /**
     * Main testing - plug in the magic file as the first arg and the target file to be examined as the second.
     *
     * Usage: java xxx.MagicNumberUtil [magic config file absolute path] [target file to be id'd]
     */
    public static void main(final String[] args) {
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (args.length &lt; 2) {</span>
<span class="nc" id="L119">            log.info(&quot;Usage: java xxx.MagicNumberUtil [magic config file absolute path] [target file to be id'd]&quot;);</span>
        }

<span class="nc" id="L122">        final MagicNumberUtil util = new MagicNumberUtil();</span>
        try {
            // make sure the magic file exists
<span class="nc" id="L125">            final File magicFile = new File(args[0]);</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">            if (!magicFile.exists()) {</span>
<span class="nc" id="L127">                log.info(&quot;Could not find the magic config file at: {}&quot;, magicFile.getAbsolutePath());</span>
<span class="nc" id="L128">                System.exit(0);</span>
            }
            // make sure the target file can be found as well
<span class="nc" id="L131">            final File target = new File(args[1]);</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">            if (!target.exists()) {</span>
<span class="nc" id="L133">                log.info(&quot;Could not find the target file at: {}&quot;, target.getAbsolutePath());</span>
            }

            // load the magic numbers
<span class="nc" id="L137">            util.load(new File(args[0]));</span>

<span class="nc" id="L139">        } catch (Exception e) {</span>
<span class="nc" id="L140">            log.error(&quot;Error in main&quot;, e);</span>
<span class="nc" id="L141">        }</span>
        // if error logging is enabled on the 'logErrors' flag then this will print out the entry and continuation
        // parsing errors
<span class="nc bnc" id="L144" title="All 2 branches missed.">        if (util.logErrors) {</span>
<span class="nc" id="L145">            log.error(util.getErrorLog());</span>
        }
<span class="nc" id="L147">    }</span>

    public void setErrorLogging(final boolean logErr) {
<span class="nc" id="L150">        this.logErrors = logErr;</span>
<span class="nc" id="L151">    }</span>

    /**
     * Input a byte array sample and it will be compared against the global magic number list. Descriptions for matching
     * entries inclusive of continuations.
     *
     * @param data a byte[]
     * @return {@link String} representing matching description plus matching continuation descriptions or null.
     * @throws RuntimeException If the magic file has not been loaded globally using the load methods.
     * @see #load(java.io.File)
     * @see #load(byte[])
     */
    public String describe(final byte[] data) {
<span class="fc" id="L164">        log.debug(&quot;Checking against {} magic items&quot;, this.magicNumbers.size());</span>
<span class="fc" id="L165">        String description = null;</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">        for (final MagicNumber item : this.magicNumbers) {</span>
<span class="fc" id="L167">            log.debug(&quot;Checking magic item {}&quot;, item);</span>
<span class="fc" id="L168">            description = item.describe(data);</span>
<span class="fc bfc" id="L169" title="All 4 branches covered.">            if (description != null &amp;&amp; !description.isEmpty()) {</span>
<span class="fc" id="L170">                break;</span>
            }
<span class="fc" id="L172">        }</span>
<span class="fc" id="L173">        return description;</span>
    }

    /**
     * Input a byte array sample and it will be compared against the global magic number list. Descriptions for matching
     * entries inclusive of continuations provided.
     *
     * @param target data a java.io.File
     * @return A string representing matching description plus matching continuation descriptions or null.
     * @throws RuntimeException If the magic file has not been loaded globally using the load methods.
     * @throws IOException If a read error occurs loading the target file.
     * @see #load(java.io.File)
     * @see #load(byte[])
     */
    public String describe(final File target) throws IOException {
        try {
<span class="nc bnc" id="L189" title="All 2 branches missed.">            if (!target.exists()) {</span>
<span class="nc" id="L190">                throw new IOException(&quot;Target file not found at: &quot; + target.getAbsolutePath());</span>
            }
<span class="nc" id="L192">        } catch (SecurityException se) {</span>
<span class="nc" id="L193">            throw new IOException(&quot;Security Exception reading file: &quot; + se.getMessage());</span>
<span class="nc" id="L194">        }</span>
<span class="nc" id="L195">        return describe(Executrix.readDataFromFile(target.getAbsolutePath()));</span>
    }

    /**
     * Do not load magic file globally and do not compare against the global magic number list and instead compare target
     * against the specified magic file. The magic file will be read/parsed each time as the comparative file. Useful for
     * debugging or if certain files can be narrowed down to a smaller magic file list improving id performance.
     *
     * @param target a java.io.File specifying the file to be id'd
     * @param magicConfig the magic file containing the magic number entries to use
     * @return {@link String} representing the id description or null
     * @throws IOException If an IO error occurs while reading either file.
     */
    public static String describe(final File target, final File magicConfig) throws IOException {
        try {
<span class="nc bnc" id="L210" title="All 2 branches missed.">            if (!target.exists()) {</span>
<span class="nc" id="L211">                throw new IOException(&quot;Target file not found at: &quot; + target.getAbsolutePath());</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">            } else if (!magicConfig.exists()) {</span>
<span class="nc" id="L213">                throw new IOException(&quot;Magic config file not found at: &quot; + magicConfig.getAbsolutePath());</span>
            }
<span class="nc" id="L215">        } catch (SecurityException se) {</span>
<span class="nc" id="L216">            throw new IOException(&quot;Security Exception reading file: &quot; + se.getMessage());</span>
<span class="nc" id="L217">        }</span>

<span class="nc" id="L219">        return describe(Executrix.readDataFromFile(target.getAbsolutePath()), magicConfig);</span>
    }

    /**
     * Do not load magic file globally and do not compare against the global magic number list and compare target against
     * the specified magic file instead. The magic file will be read/parsed each time as the comparative file. Useful for
     * debugging or if certain files can be narrowed down to a smaller magic file list improving id performance.
     *
     * @param sample a byte[] containing the data to be id'd
     * @param magicConfig the magic file containing the magic number entries to use
     * @return {@link String} representing the id description or null
     * @throws IOException If an IO error occurs while reading either file.
     */
    public static String describe(final byte[] sample, final File magicConfig) throws IOException {
        try {
<span class="nc bnc" id="L234" title="All 2 branches missed.">            if (!magicConfig.exists()) {</span>
<span class="nc" id="L235">                throw new IOException(&quot;Magic config file not found at: &quot; + magicConfig.getAbsolutePath());</span>
            }
<span class="nc" id="L237">        } catch (SecurityException se) {</span>
<span class="nc" id="L238">            throw new IOException(&quot;Security Exception reading file: &quot; + se.getMessage());</span>
<span class="nc" id="L239">        }</span>

<span class="nc" id="L241">        final List&lt;MagicNumber&gt; magicNumberList =</span>
<span class="nc" id="L242">                MagicNumberFactory.buildMagicNumberList(Executrix.readDataFromFile(magicConfig.getAbsolutePath()), null, null);</span>

<span class="nc" id="L244">        String description = null;</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">        for (final MagicNumber item : magicNumberList) {</span>
<span class="nc" id="L246">            description = item.describe(sample);</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">            if (description != null) {</span>
<span class="nc" id="L248">                break;</span>
            }
<span class="nc" id="L250">        }</span>
<span class="nc" id="L251">        return description;</span>
    }

    /**
     * Load the magic number list globally.
     *
     * @param config the java.io.File pointing to the magic file
     * @exception IOException if one occurs while reading the config file or if a security access error occurs
     */
    public void load(final File config) throws IOException {
<span class="fc" id="L261">        load(config, false);</span>
<span class="fc" id="L262">    }</span>

    /**
     * Load the magic number list globally.
     *
     * @param config the java.io.File pointing to the magic file
     * @param swallowParseException should we swallow Ignorable ParseException or bubble them up
     * @exception IOException if one occurs while reading the config file or if a security access error occurs
     */
    public void load(final File config, final boolean swallowParseException) throws IOException {
        try {
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">            if (!config.exists()) {</span>
<span class="nc" id="L274">                throw new IOException(&quot;File not found&quot;);</span>
            }
<span class="nc" id="L276">        } catch (SecurityException se) {</span>
<span class="nc" id="L277">            throw new IOException(&quot;Security Exception: &quot; + se.getMessage());</span>
<span class="fc" id="L278">        }</span>

<span class="fc" id="L280">        List&lt;String&gt; mErrorList = null;</span>
<span class="fc" id="L281">        Map&lt;String, List&lt;String&gt;&gt; mExtErrorMap = null;</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">        if (this.logErrors) {</span>
<span class="nc" id="L283">            mErrorList = this.errorList;</span>
<span class="nc" id="L284">            mExtErrorMap = this.extErrorMap;</span>
        }
<span class="fc" id="L286">        this.magicNumbers.addAll(MagicNumberFactory.buildMagicNumberList(Executrix.readDataFromFile(config.getAbsolutePath()), mErrorList,</span>
                mExtErrorMap, swallowParseException));
<span class="fc" id="L288">    }</span>

    /**
     * Load the magic number list globally.
     *
     * @param configData the byte[] containing the the magic number entry data
     */
    public void load(final byte[] configData) {
<span class="fc" id="L296">        List&lt;String&gt; mErrorList = null;</span>
<span class="fc" id="L297">        Map&lt;String, List&lt;String&gt;&gt; mExtErrorMap = null;</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        if (this.logErrors) {</span>
<span class="nc" id="L299">            mErrorList = this.errorList;</span>
<span class="nc" id="L300">            mExtErrorMap = this.extErrorMap;</span>
        }
<span class="fc" id="L302">        this.magicNumbers.addAll(MagicNumberFactory.buildMagicNumberList(configData, mErrorList, mExtErrorMap));</span>
<span class="fc" id="L303">    }</span>

    public int size() {
<span class="fc" id="L306">        return this.magicNumbers.size();</span>
    }

    public String getErrorLog() {
<span class="nc bnc" id="L310" title="All 2 branches missed.">        if (!this.logErrors) {</span>
<span class="nc" id="L311">            return &quot;&quot;;</span>
        }
<span class="nc" id="L313">        return getErrorLog(this.magicNumbers, this.errorList, this.extErrorMap);</span>
    }

    /**
     * Summarizes
     */
    public String getErrorLog(final List&lt;MagicNumber&gt; magicNumberList, final List&lt;String&gt; zeroDepthErrorList,
            final Map&lt;String, List&lt;String&gt;&gt; continuationErrorMap) {
<span class="nc" id="L321">        final StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L322">        final String lineBreak = &quot;\n###########################################################&quot;;</span>
<span class="nc" id="L323">        sb.append(lineBreak);</span>
<span class="nc" id="L324">        sb.append(&quot;\nSUMMARY&quot;);</span>
<span class="nc" id="L325">        sb.append(lineBreak);</span>
<span class="nc" id="L326">        sb.append(&quot;\nSUCCESSFUL ENTRIES.................................................. &quot;);</span>
<span class="nc" id="L327">        sb.append(magicNumberList.size() - continuationErrorMap.size());</span>
<span class="nc" id="L328">        sb.append(&quot;\nFAILED ENTRIES...................................................... &quot;);</span>
<span class="nc" id="L329">        sb.append(zeroDepthErrorList.size());</span>
<span class="nc" id="L330">        sb.append(&quot;\nPARTIALLY SUCCESSFUL ENTRIES (failed on some child continuations)... &quot;);</span>
<span class="nc" id="L331">        sb.append(continuationErrorMap.size());</span>
<span class="nc" id="L332">        sb.append('\n');</span>
<span class="nc" id="L333">        sb.append(lineBreak);</span>
<span class="nc" id="L334">        sb.append(&quot;\nFAILED ENTRIES (failed on some continuations)\n\n&quot;);</span>

<span class="nc bnc" id="L336" title="All 2 branches missed.">        for (final String err : zeroDepthErrorList) {</span>
<span class="nc" id="L337">            sb.append('\n');</span>
<span class="nc" id="L338">            sb.append(&quot;ENTRY (STATUS:FAILED): &quot;);</span>
<span class="nc" id="L339">            sb.append(err);</span>
<span class="nc" id="L340">        }</span>

<span class="nc" id="L342">        sb.append('\n');</span>
<span class="nc" id="L343">        sb.append(lineBreak);</span>
<span class="nc" id="L344">        sb.append(&quot;\nPARTIALLY SUCCESSFUL ENTRIES (failed on some extensions)\n\n&quot;);</span>

<span class="nc bnc" id="L346" title="All 2 branches missed.">        for (final String entry : continuationErrorMap.keySet()) {</span>
<span class="nc" id="L347">            sb.append('\n');</span>
<span class="nc" id="L348">            sb.append(&quot;MAIN ENTRY (STATUS:SUCCESSFUL): &quot;);</span>
<span class="nc" id="L349">            sb.append(entry);</span>

<span class="nc bnc" id="L351" title="All 2 branches missed.">            for (final String extValue : continuationErrorMap.get(entry)) {</span>
<span class="nc" id="L352">                sb.append(&quot;\n\tCONTINUATION (STATUS:FAILED): &quot;);</span>
<span class="nc" id="L353">                sb.append(extValue);</span>
<span class="nc" id="L354">            }</span>
<span class="nc" id="L355">        }</span>

<span class="nc" id="L357">        return sb.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>